from fastapi import APIRouter, HTTPException, status, Depends
from typing import Optional
from uuid import UUID, uuid4
from datetime import datetime

from service.config import get_settings
from service.db.models import User, UserPersonalData
from service.routers.auth import verify_authentication, RequireAuth
from pydantic import BaseModel, EmailStr

router = APIRouter(tags=["Users V2"])
db = get_settings().get_db()

# Pydantic Models for V2 User Endpoints
class UserCreateRequest(BaseModel):
    name: str
    email: EmailStr
    # api_key will be generated by the system

class UserPersonalDataResponse(BaseModel):
    user_id: UUID
    name: str
    email: EmailStr
    api_key: str
    last_login: Optional[datetime] = None
    updated_at: datetime

class UserUpdateRequest(BaseModel):
    name: Optional[str] = None
    email: Optional[EmailStr] = None

class UserResponse(BaseModel):
    id: UUID
    is_active: bool
    created_at: datetime
    deleted_at: Optional[datetime] = None

@router.post("/users", response_model=UserPersonalDataResponse, status_code=status.HTTP_201_CREATED)
async def create_user(user_data: UserCreateRequest):
    """
    Register a new user and generate an API key.
    """
    try:
        user, user_personal_data = await db.users.add_user(user_data.name, user_data.email)
        return UserPersonalDataResponse(
            user_id=user_personal_data.user_id,
            name=user_personal_data.name,
            email=user_personal_data.email,
            api_key=user_personal_data.api_key,
            last_login=user_personal_data.last_login,
            updated_at=user_personal_data.updated_at
        )
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Error creating user: {e}")

@router.get("/users/me", response_model=UserPersonalDataResponse)
async def get_current_user(current_user_personal_data: UserPersonalData = RequireAuth): # Removed Depends()
    """
    Retrieve the authenticated user's personal data.
    """
    return current_user_personal_data

@router.put("/users/me", response_model=UserPersonalDataResponse)
async def update_current_user(
    user_update: UserUpdateRequest,
    current_user_personal_data: UserPersonalData = RequireAuth # Removed Depends()
):
    """
    Update the authenticated user's personal data.
    """
    # This method would need a new function in user_repo to update personal data
    # For now, let's assume we update name and email in user_personal_data
    # A direct update method in user_repo is needed for user_personal_data
    # For simplicity, I'll simulate the update here, but a repo method is preferred.
    
    # In a real scenario, you'd call a user_repo method like:
    # updated_personal_data = await db.users.update_user_personal_data(
    #     user_id=current_user_personal_data.user_id,
    #     name=user_update.name,
    #     email=user_update.email
    # )
    # if not updated_personal_data:
    #     raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User personal data not found or not updated.")
    # return updated_personal_data

    raise HTTPException(status_code=status.HTTP_501_NOT_IMPLEMENTED, detail="Update user personal data endpoint not yet implemented in repository.")

@router.delete("/users/me", status_code=status.HTTP_204_NO_CONTENT)
async def soft_delete_user(current_user_personal_data: UserPersonalData = RequireAuth): # Removed Depends()
    """
    Soft-delete the authenticated user's account (sets deleted_at timestamp).
    """
    # This requires a new method in user_repo to set deleted_at on the 'users' table
    # For simplicity, I'll simulate the soft delete here.
    
    # In a real scenario, you'd call a user_repo method like:
    # success = await db.users.soft_delete_user(current_user_personal_data.user_id)
    # if not success:
    #     raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User not found or already deleted.")
    
    raise HTTPException(status_code=status.HTTP_501_NOT_IMPLEMENTED, detail="Soft delete user endpoint not yet implemented in repository.")

@router.post("/users/me/gdpr-erase", status_code=status.HTTP_204_NO_CONTENT)
async def gdpr_erase_user_data(current_user_personal_data: UserPersonalData = RequireAuth): # Removed Depends()
    """
    Trigger GDPR erasure for the authenticated user (anonymizes personal data).
    This is a sensitive operation.
    """
    # This requires a new method in user_repo to anonymize user_personal_data
    # For simplicity, I'll simulate the erasure here.
    
    # In a real scenario, you'd call a user_repo method like:
    # success = await db.users.anonymize_user_personal_data(current_user_personal_data.user_id)
    # if not success:
    #     raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="User personal data not found or already anonymized.")
    
    raise HTTPException(status_code=status.HTTP_501_NOT_IMPLEMENTED, detail="GDPR erase endpoint not yet implemented in repository.")
